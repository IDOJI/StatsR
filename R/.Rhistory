parallel.cores)
path_Export = "/Users/Ido/Library/CloudStorage/Dropbox/Github/Papers/Papers___Wrting/Papers___Exploring Resting-State fMRI Signals in Alzheimer's Disease Using Functional Data Analysis/Data/5.Classification___MSGL___0.9"
Classification___Multinomial___MSGL___Fitting.by.CV = function(X,
y,
features.grouping,
n_fold,
alpha_seq,
lambda.min,
d,
lambda.min.rel,
sparse.data,
standardize,
parallel.cores,
path_Export){
#=========================================================================
# Data-derived lambdas
#=========================================================================
lambda_seq = msgl::lambda(x = as.matrix(X),
classes = y,
sampleWeights = NULL,
grouping = features.grouping,
groupWeights = NULL,
parameterWeights = NULL,
alpha = alpha,
d = d,
standardize,
lambda.min,
intercept = TRUE,
sparse.data = sparse.data,
lambda.min.rel = lambda.min.rel,
algorithm.config = msgl::msgl.standard.config)
#=========================================================================
# Model fitting
#=========================================================================
# packages
install_packages(c("parallel", "msgl"))
# parallel starts
cl = makeCluster(parallel.cores) ; registerDoParallel(cl)
# Fitting models
All_Fit_CV = lapply(alpha_seq, function(ith_alpha, ...){
# < fitting by cv >
# information about models
# and cross validation errors (estimated expected generalization error)
tictoc::tic()
ith_fit.cv = msgl::cv(x = X,
classes = y,
grouping = features.grouping,
fold = n_fold,
alpha = ith_alpha,
lambda = lambda_seq,
sparse.data = sparse.data,
use_parallel = TRUE)
# Exporting
saveRDS(ith_fit.cv, file=paste0(path_Export, "/Fitted_CV", "___", ith_alpha, ".rds"))
tictoc::toc()
return(ith_fit.cv)
})
# parallel stop
stopCluster(cl)
#=========================================================================
# Returning
#=========================================================================
return(All_Fit_CV)
}
Classification___Multinomial___MSGL___Fitting.by.CV = function(X,
y,
features.grouping,
n_fold,
alpha_seq,
lambda.min,
d,
lambda.min.rel,
sparse.data,
standardize,
parallel.cores,
path_Export){
#=========================================================================
# Data-derived lambdas
#=========================================================================
lambda_seq = msgl::lambda(x = as.matrix(X),
classes = y,
sampleWeights = NULL,
grouping = features.grouping,
groupWeights = NULL,
parameterWeights = NULL,
alpha = alpha,
d = d,
standardize,
lambda.min,
intercept = TRUE,
sparse.data = sparse.data,
lambda.min.rel = lambda.min.rel,
algorithm.config = msgl::msgl.standard.config)
#=========================================================================
# Model fitting
#=========================================================================
# packages
install_packages(c("parallel", "msgl"))
# parallel starts
cl = makeCluster(parallel.cores) ; registerDoParallel(cl)
# Fitting models
All_Fit_CV = lapply(alpha_seq, function(ith_alpha, ...){
# < fitting by cv >
# information about models
# and cross validation errors (estimated expected generalization error)
tictoc::tic()
ith_fit.cv = msgl::cv(x = X,
classes = y,
grouping = features.grouping,
fold = n_fold,
alpha = ith_alpha,
lambda = lambda_seq,
sparse.data = sparse.data,
use_parallel = TRUE)
# Exporting
saveRDS(ith_fit.cv, file=paste0(path_Export, "/Fitted_CV", "___", ith_alpha, ".rds"))
tictoc::toc()
return(ith_fit.cv)
})
# parallel stop
stopCluster(cl)
#=========================================================================
# Returning
#=========================================================================
return(All_Fit_CV)
}
Fit_CV.list
#=============================================================================
# Fitting CV
#=============================================================================
Fit_CV.list = Classification___Multinomial___MSGL___Fitting.by.CV(X = Train_X,
y = Train_y,
features.grouping,
n_fold,
alpha_seq[30:31],
lambda.min,
d,
lambda.min.rel,
sparse.data,
standardize,
parallel.cores,
path_Export)
#===========================================================================
# Extract best error for each CV
#===========================================================================
Errors = sapply(Fit_CV.list, function(ith_Fit_CV){
# ith_Fit_CV = Fit_CV.list[[1]]
#===========================================================================
# which best?
#===========================================================================
ith_which_best = sglOptim::best_model(fit.cv)
#===========================================================================
# Error
#===========================================================================
# Extract Cross validation errors (estimated expected generalization error)
# Misclassification rate
Best_Error = sglOptim::Err(ith_Fit_CV)[ith_which_best]
return(Best_Error)
})
Errors
#===========================================================================
# Extract best error for each CV
#===========================================================================
Errors = sapply(Fit_CV.list, function(ith_Fit_CV){
# ith_Fit_CV = Fit_CV.list[[1]]
#===========================================================================
# which best?
#===========================================================================
ith_which_best = sglOptim::best_model(ith_Fit.cv)
#===========================================================================
# Error
#===========================================================================
# Extract Cross validation errors (estimated expected generalization error)
# Misclassification rate
Best_Error = sglOptim::Err(ith_Fit_CV)[ith_which_best]
return(Best_Error)
})
#===========================================================================
# Extract best error for each CV
#===========================================================================
Errors = sapply(Fit_CV.list, function(ith_Fit_CV){
# ith_Fit_CV = Fit_CV.list[[1]]
#===========================================================================
# which best?
#===========================================================================
ith_which_best = sglOptim::best_model(ith_Fit_CV)
#===========================================================================
# Error
#===========================================================================
# Extract Cross validation errors (estimated expected generalization error)
# Misclassification rate
Best_Error = sglOptim::Err(ith_Fit_CV)[ith_which_best]
return(Best_Error)
})
Errors
ith_Fit_CV = Fit_CV.list[[1]]
# ith_Fit_CV = Fit_CV.list[[1]]
#===========================================================================
# which best?
#===========================================================================
ith_which_best = sglOptim::best_model(ith_Fit_CV)
ith_which_best
#===========================================================================
# Which error is the lowest?
#===========================================================================
Best_CV = Fit_CV.list[[which.min(Errors)]]
Best_CV
#===========================================================================
# Which error is the lowest?
#===========================================================================
Best_CV = Fit_CV.list[[which.min(Errors)]]
Best_CV$features
Best_CV$parameters
Best_CV$lambda
lambda.min
#=========================================================================
# Data-derived lambdas
#=========================================================================
lambda_seq = msgl::lambda(x = as.matrix(X),
classes = y,
sampleWeights = NULL,
grouping = features.grouping,
groupWeights = NULL,
parameterWeights = NULL,
alpha = alpha,
d = d,
standardize,
lambda.min,
intercept = TRUE,
sparse.data = sparse.data,
lambda.min.rel = lambda.min.rel,
algorithm.config = msgl::msgl.standard.config)
X = Train_X
y = Train_y
#=========================================================================
# Data-derived lambdas
#=========================================================================
lambda_seq = msgl::lambda(x = as.matrix(X),
classes = y,
sampleWeights = NULL,
grouping = features.grouping,
groupWeights = NULL,
parameterWeights = NULL,
alpha = alpha,
d = d,
standardize,
lambda.min,
intercept = TRUE,
sparse.data = sparse.data,
lambda.min.rel = lambda.min.rel,
algorithm.config = msgl::msgl.standard.config)
lambda_seq
Classification___Multinomial___MSGL___Fitting.by.CV = function(X,
y,
features.grouping,
n_fold,
alpha_seq,
lambda.min,
d,
lambda.min.rel,
sparse.data,
standardize,
parallel.cores,
path_Export){
#=========================================================================
# Data-derived lambdas
#=========================================================================
lambda_seq = msgl::lambda(x = as.matrix(X),
classes = y,
sampleWeights = NULL,
grouping = features.grouping,
groupWeights = NULL,
parameterWeights = NULL,
alpha = alpha,
d = d,
standardize,
lambda.min,
intercept = TRUE,
sparse.data = sparse.data,
lambda.min.rel = lambda.min.rel,
algorithm.config = msgl::msgl.standard.config)
#=========================================================================
# Model fitting
#=========================================================================
# packages
install_packages(c("parallel", "msgl"))
# parallel starts
cl = makeCluster(parallel.cores) ; registerDoParallel(cl)
# Fitting models
All_Fit_CV = lapply(alpha_seq, function(ith_alpha, ...){
# < fitting by cv >
# information about models
# and cross validation errors (estimated expected generalization error)
tictoc::tic()
ith_fit.cv = msgl::cv(x = X,
classes = y,
grouping = features.grouping,
fold = n_fold,
alpha = ith_alpha,
lambda = lambda_seq,
sparse.data = sparse.data,
use_parallel = TRUE)
# Exporting
saveRDS(ith_fit.cv, file=paste0(path_Export, "/Fitted_CV", "___", ith_alpha, ".rds"))
tictoc::toc()
return(ith_fit.cv)
})
# parallel stop
stopCluster(cl)
#=========================================================================
# Returning
#=========================================================================
return(All_Fit_CV)
}
Best_CV$type
Best_CV$collapse
#=========================================================================
# Extract best error for each CV
#=========================================================================
Best_CV$lambda
which.min(Errors)
sglOptim::best_model(Best_CV)
Best_CV$lambda[[1]][32]
sglOptim::best_model(Best_CV)
Best_CV
Classification___Multinomial___MSGL___Select.Best.Model = function(Fit_CV.list){
#===========================================================================
# Extract best error for each CV
#===========================================================================
Errors = sapply(Fit_CV.list, function(ith_Fit_CV){
# ith_Fit_CV = Fit_CV.list[[1]]
#===========================================================================
# which best?
#===========================================================================
ith_which_best = sglOptim::best_model(ith_Fit_CV)
#===========================================================================
# Error
#===========================================================================
# Extract Cross validation errors (estimated expected generalization error)
# Misclassification rate
Best_Error = sglOptim::Err(ith_Fit_CV)[ith_which_best]
return(Best_Error)
})
#===========================================================================
# Which error is the lowest?
#===========================================================================
Best_CV = Fit_CV.list[[which.min(Errors)]]
#=========================================================================
# Extract best error for each CV
#=========================================================================
# sglOptim::best_model(Best_CV)
# Best_CV$lambda[[1]][32]
# fit <- msgl::fit(x, classes, alpha = 0.5, lambda = 0.1)
return(Best_CV)
}
Best_CV = Classification___Multinomial___MSGL___Select.Best.Model(Fit_CV.list)
Classification___Multinomial___MSGL___Select.Best.Model = function(Fit_CV.list){
#===========================================================================
# Extract best error for each CV
#===========================================================================
Errors = sapply(Fit_CV.list, function(ith_Fit_CV){
# ith_Fit_CV = Fit_CV.list[[1]]
#===========================================================================
# which best?
#===========================================================================
ith_which_best = sglOptim::best_model(ith_Fit_CV)
#===========================================================================
# Error
#===========================================================================
# Extract Cross validation errors (estimated expected generalization error)
# Misclassification rate
Best_Error = sglOptim::Err(ith_Fit_CV)[ith_which_best]
return(Best_Error)
})
#===========================================================================
# Which error is the lowest?
#===========================================================================
Best_CV = Fit_CV.list[[which.min(Errors)]]
#=========================================================================
# Extract best error for each CV
#=========================================================================
# sglOptim::best_model(Best_CV)
# Best_CV$lambda[[1]][32]
# fit <- msgl::fit(x, classes, alpha = 0.5, lambda = 0.1)
return(Best_CV)
}
Best_CV
length(Fit_CV.list)
#===========================================================================
# Which error is the lowest?
#===========================================================================
which_min_error = which.min(Errors)
alpha_seq
Best_alpha = alpha_seq[which_min_error]
Best_alpha
Best_CV = Fit_CV.list[[which_min_error]]
Classification___Multinomial___MSGL___Select.Best.Model = function(Fit_CV.list, alpha_seq){
#===========================================================================
# Extract best error for each CV
#===========================================================================
Errors = sapply(Fit_CV.list, function(ith_Fit_CV){
# ith_Fit_CV = Fit_CV.list[[1]]
#===========================================================================
# which best?
#===========================================================================
ith_which_best = sglOptim::best_model(ith_Fit_CV)
#===========================================================================
# Error
#===========================================================================
# Extract Cross validation errors (estimated expected generalization error)
# Misclassification rate
Best_Error = sglOptim::Err(ith_Fit_CV)[ith_which_best]
return(Best_Error)
})
#===========================================================================
# Which error is the lowest?
#===========================================================================
which_min_error = which.min(Errors)
Best_alpha = alpha_seq[which_min_error]
Best_CV = Fit_CV.list[[which_min_error]]
#=========================================================================
# Extract best error for each CV
#=========================================================================
# sglOptim::best_model(Best_CV)
# Best_CV$lambda[[1]][32]
# fit <- msgl::fit(x, classes, alpha = 0.5, lambda = 0.1)
return(list(Best_CV = Best_CV, Best_alpha = Best_alpha))
}
#=============================================================================
# Find the best model from CV list
#=============================================================================
Best_CV = Classification___Multinomial___MSGL___Select.Best.Model(Fit_CV.list)
#=============================================================================
# Find the best model from CV list
#=============================================================================
Best_CV = Classification___Multinomial___MSGL___Select.Best.Model(Fit_CV.list, alpha_seq)
Best_CV
sglOptim::get_coef(Best_CV$Best_CV)
sglOptim::models(Best_CV$Best_CV)
sglOptim::sgl_print(Best_CV$Best_CV)
sglOptim::sgl_print(Best_CV$Best_CV) %>% clasee
sglOptim::sgl_print(Best_CV$Best_CV) %>% clase
sglOptim::sgl_print(Best_CV$Best_CV) %>% class
sglOptim::prepare.args(Best_CV$Best_CV)
(Best_CV$Best_CV$parameters)
(Best_CV$Best_CV$parameters)[[1]]
(Best_CV$Best_CV$parameters)[1]
(Best_CV$Best_CV$parameters)[[1]] %>% length
(Best_CV$Best_CV$parameters) %>% class
(Best_CV$Best_CV$parameters) %>% dim
Best_CV$Best_CV$call
Best_CV$Best_CV$PACKAGE
Best_CV$Best_CV$features
data = read.csv("/Users/Ido/Library/CloudStorage/Dropbox/Github/Papers___Data/ADNI___RS.fMRI___Subjects.Lists/Subjects_Lists_Exported/Final/[Final_Selected]_Subjects_list.csv")
data$DEMO___SEX %>% table
data$DEMO___DIAGNOSIS_NEW %>% table
data$DEMO___AGE %>% sd
data$DEMO___AGE %>% mean
data$DEMO___SEX %>% table
age_F = data %>% filter(DEMO___SEX == "Female") %>% select(AGE) %>% unlist
age_F = data %>% filter(DEMO___SEX == "Female") %>% select(DEMO___AGE) %>% unlist
age_F = data %>% filter(DEMO___SEX == "Female") %>% dplyr::select(DEMO___AGE) %>% unlist
age_F
# AGE of each sex
age_F = data %>% filter(DEMO___SEX == "Female") %>% dplyr::select(DEMO___AGE) %>% unlist
age_M = data %>% filter(DEMO___SEX == "Male") %>% dplyr::select(DEMO___AGE) %>% unlist
mean(age_F)
sd(age_F)
mean(age_F)
sd(age_F)
data$PTDEMO___PTEDUCAT
data$PTDEMO___PTEDUCAT %>% table
# SEX
data$DEMO___SEX %>% table
# AGE of total
data$DEMO___AGE %>% sd
data$DEMO___AGE %>% mean
# AGE of each sex
age_F = data %>% filter(DEMO___SEX == "Female") %>% dplyr::select(DEMO___AGE) %>% unlist
age_M = data %>% filter(DEMO___SEX == "Male") %>% dplyr::select(DEMO___AGE) %>% unlist
mean(age_F)
sd(age_F)
mean(age_M)
sd(age_M)
# diagnosis
data$DEMO___DIAGNOSIS_NEW %>% table
413    +376
data = read.csv("/Users/Ido/Library/CloudStorage/Dropbox/Github/Papers___Data/ADNI___RS.fMRI___Subjects.Lists/Subjects_Lists_Exported/Final/[Final_Selected]_Subjects_list.csv")
data = data %>% filter(NFQ___BAND.TYPE=="SB")
data = data %>% filter(NFQ___BAND.TYPE=="SB")
# SEX
data$DEMO___SEX %>% table
# AGE of total
data$DEMO___AGE %>% sd
data$DEMO___AGE %>% mean
# AGE of each sex
age_F = data %>% filter(DEMO___SEX == "Female") %>% dplyr::select(DEMO___AGE) %>% unlist
age_M = data %>% filter(DEMO___SEX == "Male") %>% dplyr::select(DEMO___AGE) %>% unlist
mean(age_F)
sd(age_F)
mean(age_M)
sd(age_M)
# diagnosis
data$DEMO___DIAGNOSIS_NEW %>% table
Atlas_Labels = c("Precentral_L", "Precentral_R", "Frontal_Sup_2_L", "Frontal_Sup_2_R", "Frontal_Mid_2_L", "Frontal_Mid_2_R", "Frontal_Inf_Oper_L", "Frontal_Inf_Oper_R", "Frontal_Inf_Tri_L", "Frontal_Inf_Tri_R", "Frontal_Inf_Orb_2_L", "Frontal_Inf_Orb_2_R", "Rolandic_Oper_L", "Rolandic_Oper_R", "Supp_Motor_Area_L", "Supp_Motor_Area_R", "Olfactory_L", "Olfactory_R", "Frontal_Sup_Medial_L", "Frontal_Sup_Medial_R", "Frontal_Med_Orb_L", "Frontal_Med_Orb_R", "Rectus_L", "Rectus_R", "OFCmed_L", "OFCmed_R", "OFCant_L", "OFCant_R", "OFCpost_L", "OFCpost_R", "OFClat_L", "OFClat_R", "Insula_L", "Insula_R", "Cingulate_Ant_L", "Cingulate_Ant_R", "Cingulate_Mid_L", "Cingulate_Mid_R", "Cingulate_Post_L", "Cingulate_Post_R", "Hippocampus_L", "Hippocampus_R", "ParaHippocampal_L", "ParaHippocampal_R", "Amygdala_L", "Amygdala_R", "Calcarine_L", "Calcarine_R", "Cuneus_L", "Cuneus_R", "Lingual_L", "Lingual_R", "Occipital_Sup_L", "Occipital_Sup_R", "Occipital_Mid_L", "Occipital_Mid_R", "Occipital_Inf_L", "Occipital_Inf_R", "Fusiform_L", "Fusiform_R", "Postcentral_L", "Postcentral_R", "Parietal_Sup_L", "Parietal_Sup_R", "Parietal_Inf_L", "Parietal_Inf_R", "SupraMarginal_L", "SupraMarginal_R", "Angular_L", "Angular_R", "Precuneus_L", "Precuneus_R", "Paracentral_Lobule_L", "Paracentral_Lobule_R", "Caudate_L", "Caudate_R", "Putamen_L", "Putamen_R", "Pallidum_L", "Pallidum_R", "Thalamus_L", "Thalamus_R", "Heschl_L", "Heschl_R", "Temporal_Sup_L", "Temporal_Sup_R", "Temporal_Pole_Sup_L", "Temporal_Pole_Sup_R", "Temporal_Mid_L", "Temporal_Mid_R", "Temporal_Pole_Mid_L", "Temporal_Pole_Mid_R", "Temporal_Inf_L", "Temporal_Inf_R", "Cerebellum_Crus1_L", "Cerebellum_Crus1_R", "Cerebellum_Crus2_L", "Cerebellum_Crus2_R", "Cerebellum_3_L", "Cerebellum_3_R", "Cerebellum_4_5_L", "Cerebellum_4_5_R", "Cerebellum_6_L", "Cerebellum_6_R", "Cerebellum_7b_L", "Cerebellum_7b_R", "Cerebellum_8_L", "Cerebellum_8_R", "Cerebellum_9_L", "Cerebellum_9_R", "Cerebellum_10_L", "Cerebellum_10_R", "Vermis_1_2", "Vermis_3", "Vermis_4_5", "Vermis_6", "Vermis_7", "Vermis_8", "Vermis_9", "Vermis_10", "Thal_AV_L", "Thal_AV_R", "Thal_LP_L", "Thal_LP_R", "Thal_VA_L", "Thal_VA_R", "Thal_VL_L", "Thal_VL_R", "Thal_VPL_L", "Thal_VPL_R", "Thal_IL_L", "Thal_IL_R", "Thal_Re_L", "Thal_Re_R", "Thal_MDm_L", "Thal_MDm_R", "Thal_MDl_L", "Thal_MDl_R", "Thal_LGN_L", "Thal_LGN_R", "Thal_MGN_L", "Thal_MGN_R", "Thal_PuI_L", "Thal_PuI_R", "Thal_PuM_L", "Thal_PuM_R", "Thal_PuA_L", "Thal_PuA_R", "Thal_PuL_L", "Thal_PuL_R", "ACC_sub_L", "ACC_sub_R", "ACC_pre_L", "ACC_pre_R", "ACC_sup_L", "ACC_sup_R", "N_Acc_L", "N_Acc_R", "VTA_L", "VTA_R", "SN_pc_L", "SN_pc_R", "SN_pr_L", "SN_pr_R", "Red_N_L", "Red_N_R", "LC_L", "LC_R", "Raphe_D", "Raphe_M")
grep("Hipocam", Atals_Labels)
Atlas_Labels = c("Precentral_L", "Precentral_R", "Frontal_Sup_2_L", "Frontal_Sup_2_R", "Frontal_Mid_2_L", "Frontal_Mid_2_R", "Frontal_Inf_Oper_L", "Frontal_Inf_Oper_R", "Frontal_Inf_Tri_L", "Frontal_Inf_Tri_R", "Frontal_Inf_Orb_2_L", "Frontal_Inf_Orb_2_R", "Rolandic_Oper_L", "Rolandic_Oper_R", "Supp_Motor_Area_L", "Supp_Motor_Area_R", "Olfactory_L", "Olfactory_R", "Frontal_Sup_Medial_L", "Frontal_Sup_Medial_R", "Frontal_Med_Orb_L", "Frontal_Med_Orb_R", "Rectus_L", "Rectus_R", "OFCmed_L", "OFCmed_R", "OFCant_L", "OFCant_R", "OFCpost_L", "OFCpost_R", "OFClat_L", "OFClat_R", "Insula_L", "Insula_R", "Cingulate_Ant_L", "Cingulate_Ant_R", "Cingulate_Mid_L", "Cingulate_Mid_R", "Cingulate_Post_L", "Cingulate_Post_R", "Hippocampus_L", "Hippocampus_R", "ParaHippocampal_L", "ParaHippocampal_R", "Amygdala_L", "Amygdala_R", "Calcarine_L", "Calcarine_R", "Cuneus_L", "Cuneus_R", "Lingual_L", "Lingual_R", "Occipital_Sup_L", "Occipital_Sup_R", "Occipital_Mid_L", "Occipital_Mid_R", "Occipital_Inf_L", "Occipital_Inf_R", "Fusiform_L", "Fusiform_R", "Postcentral_L", "Postcentral_R", "Parietal_Sup_L", "Parietal_Sup_R", "Parietal_Inf_L", "Parietal_Inf_R", "SupraMarginal_L", "SupraMarginal_R", "Angular_L", "Angular_R", "Precuneus_L", "Precuneus_R", "Paracentral_Lobule_L", "Paracentral_Lobule_R", "Caudate_L", "Caudate_R", "Putamen_L", "Putamen_R", "Pallidum_L", "Pallidum_R", "Thalamus_L", "Thalamus_R", "Heschl_L", "Heschl_R", "Temporal_Sup_L", "Temporal_Sup_R", "Temporal_Pole_Sup_L", "Temporal_Pole_Sup_R", "Temporal_Mid_L", "Temporal_Mid_R", "Temporal_Pole_Mid_L", "Temporal_Pole_Mid_R", "Temporal_Inf_L", "Temporal_Inf_R", "Cerebellum_Crus1_L", "Cerebellum_Crus1_R", "Cerebellum_Crus2_L", "Cerebellum_Crus2_R", "Cerebellum_3_L", "Cerebellum_3_R", "Cerebellum_4_5_L", "Cerebellum_4_5_R", "Cerebellum_6_L", "Cerebellum_6_R", "Cerebellum_7b_L", "Cerebellum_7b_R", "Cerebellum_8_L", "Cerebellum_8_R", "Cerebellum_9_L", "Cerebellum_9_R", "Cerebellum_10_L", "Cerebellum_10_R", "Vermis_1_2", "Vermis_3", "Vermis_4_5", "Vermis_6", "Vermis_7", "Vermis_8", "Vermis_9", "Vermis_10", "Thal_AV_L", "Thal_AV_R", "Thal_LP_L", "Thal_LP_R", "Thal_VA_L", "Thal_VA_R", "Thal_VL_L", "Thal_VL_R", "Thal_VPL_L", "Thal_VPL_R", "Thal_IL_L", "Thal_IL_R", "Thal_Re_L", "Thal_Re_R", "Thal_MDm_L", "Thal_MDm_R", "Thal_MDl_L", "Thal_MDl_R", "Thal_LGN_L", "Thal_LGN_R", "Thal_MGN_L", "Thal_MGN_R", "Thal_PuI_L", "Thal_PuI_R", "Thal_PuM_L", "Thal_PuM_R", "Thal_PuA_L", "Thal_PuA_R", "Thal_PuL_L", "Thal_PuL_R", "ACC_sub_L", "ACC_sub_R", "ACC_pre_L", "ACC_pre_R", "ACC_sup_L", "ACC_sup_R", "N_Acc_L", "N_Acc_R", "VTA_L", "VTA_R", "SN_pc_L", "SN_pc_R", "SN_pr_L", "SN_pr_R", "Red_N_L", "Red_N_R", "LC_L", "LC_R", "Raphe_D", "Raphe_M")
Atlas_Labels
grep("Hipocam", Atlas_Labels)
grep("Hipo", Atlas_Labels)
grep("Hippo", Atlas_Labels)
Atlas_Labels[grep("Hippo", Atlas_Labels)]
